---
id: implement-scrollback-buffer-with
level: task
title: "Implement scrollback buffer with mouse wheel and keyboard navigation"
short_code: "CRT-T-0049"
created_at: 2025-11-26T21:26:29.387531+00:00
updated_at: 2025-11-26T21:49:04.125779+00:00
parent: CRT-I-0010
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0010
---

# Implement scrollback buffer with mouse wheel and keyboard navigation

## Parent Initiative
[[CRT-I-0010]]

## Objective
Enable users to scroll through terminal history using mouse wheel and keyboard shortcuts (Shift+PageUp/PageDown). Currently the terminal only shows the live viewport with no access to previous output.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] Mouse wheel scrolls terminal viewport up/down through scrollback history
- [ ] Shift+PageUp scrolls up one page, Shift+PageDown scrolls down one page  
- [ ] Shift+Home scrolls to top of history, Shift+End scrolls to bottom (live)
- [ ] Scrollback buffer stores at least 10,000 lines of history
- [ ] Scrolling back shows visual indicator (scrollbar or position hint)
- [ ] New output auto-scrolls to bottom only when already at bottom
- [ ] Selecting text while scrolled back works correctly

## Implementation Notes

### Current State
- `crt-core/src/lib.rs:97`: Uses `TermConfig::default()` with default history size
- `src/window.rs:147`: Calls `terminal.renderable_content()` which respects scroll offset
- No `WindowEvent::MouseWheel` handling in `main.rs`
- No keyboard shortcuts for scrolling in `input.rs`

### Technical Approach

**1. Configure scrollback in Terminal::new()**
```rust
// crt-core/src/lib.rs
let mut config = TermConfig::default();
config.scrolling.history = 10000;  // Lines of scrollback
```

**2. Add scroll API to Terminal/ShellTerminal**
```rust
// crt-core/src/lib.rs
pub fn scroll(&mut self, delta: i32) {
    self.term.scroll_display(Scroll::Delta(delta));
}
pub fn scroll_to_bottom(&mut self) {
    self.term.scroll_display(Scroll::Bottom);
}
```

**3. Handle mouse wheel in main.rs**
```rust
WindowEvent::MouseWheel { delta, .. } => {
    let lines = match delta {
        MouseScrollDelta::LineDelta(_, y) => y as i32,
        MouseScrollDelta::PixelDelta(pos) => (pos.y / line_height) as i32,
    };
    shell.scroll(-lines);  // Negative = scroll up
}
```

**4. Handle keyboard shortcuts in input.rs**
- Shift+PageUp: `shell.scroll(-rows)` (one page up)
- Shift+PageDown: `shell.scroll(rows)` (one page down)
- Shift+Home: Scroll to top of history
- Shift+End: Scroll to bottom

**5. Track scroll position for visual indicator**
- `term.grid().display_offset()` returns current scroll position
- Show position/total in status line or mini-scrollbar

### Files to Modify
- `crates/crt-core/src/lib.rs`: Add scroll methods, configure history size
- `src/main.rs`: Handle `WindowEvent::MouseWheel`
- `src/input.rs`: Add keyboard scroll handlers
- `src/window.rs`: May need to track scroll state for visual indicator

### Dependencies
- alacritty_terminal `Scroll` enum and `scroll_display()` method
- winit `MouseScrollDelta` for wheel events

### Risk Considerations
- Large scrollback may increase memory usage (~10KB per 1000 lines)
- Selection coordinates need to account for scroll offset
- Content hash may need to include scroll position to trigger redraws

## Status Updates
*To be added during implementation*