---
id: implement-mouse-reporting-protocol
level: task
title: "Implement mouse reporting protocol for TUI apps"
short_code: "CRT-T-0053"
created_at: 2025-11-26T21:26:32.928572+00:00
updated_at: 2025-11-27T00:06:04.917247+00:00
parent: CRT-I-0010
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0010
---

# Implement mouse reporting protocol for TUI apps

## Parent Initiative
[[CRT-I-0010]]

## Objective
Forward mouse events to the terminal when applications request mouse reporting (vim, tmux, htop, etc.). This enables mouse-based navigation, selection, and interaction in TUI applications.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] Mouse clicks reported to terminal when mouse mode is enabled
- [ ] Mouse movement reported when tracking mode is enabled
- [ ] Mouse scroll wheel reported as scroll events
- [ ] SGR extended mouse mode (1006) supported for coordinates > 223
- [ ] Mouse mode disabled = local selection behavior (existing)
- [ ] Test with vim (mouse=a), tmux, htop, and ranger

## Implementation Notes

### Current State
- Mouse events handled locally for text selection only
- No mouse events forwarded to PTY
- No tracking of terminal mouse mode state
- `TermMode` not re-exported from alacritty_terminal

### Technical Approach

**1. Re-export TermMode from crt-core**
```rust
// crt-core/src/lib.rs
pub use alacritty_terminal::term::TermMode;
```

**2. Check mouse mode before handling events**
```rust
// input.rs or main.rs
fn should_report_mouse(shell: &ShellTerminal) -> bool {
    let mode = shell.terminal().inner().mode();
    mode.intersects(
        TermMode::MOUSE_REPORT_CLICK |
        TermMode::MOUSE_DRAG |
        TermMode::MOUSE_MOTION |
        TermMode::SGR_MOUSE
    )
}
```

**3. Generate mouse escape sequences**
```rust
fn mouse_report(button: u8, col: usize, line: usize, pressed: bool, sgr_mode: bool) -> Vec<u8> {
    if sgr_mode {
        // SGR extended mode: \x1b[<Btn;Col;RowM (press) or m (release)
        let suffix = if pressed { 'M' } else { 'm' };
        format!("\x1b[<{};{};{}{}", button, col + 1, line + 1, suffix).into_bytes()
    } else {
        // Legacy X10 mode: \x1b[M<btn+32><col+33><row+33>
        let mut seq = vec![0x1b, b'[', b'M'];
        seq.push(button + 32);
        seq.push((col + 33).min(255) as u8);
        seq.push((line + 33).min(255) as u8);
        seq
    }
}
```

**4. Update mouse event handlers**
```rust
// main.rs WindowEvent::MouseInput
fn handle_mouse_input(state: &mut WindowState, button: MouseButton, pressed: bool) {
    let shell = get_active_shell(state);
    
    if should_report_mouse(shell) {
        let (col, line) = screen_to_cell(state, state.cursor_position);
        let btn = match button {
            MouseButton::Left => 0,
            MouseButton::Middle => 1,
            MouseButton::Right => 2,
            _ => return,
        };
        let sgr = shell.terminal().inner().mode().contains(TermMode::SGR_MOUSE);
        let seq = mouse_report(btn, col, line, pressed, sgr);
        shell.send_input(&seq);
    } else if button == MouseButton::Left {
        // Existing selection behavior
        handle_terminal_mouse_press(state, ...);
    }
}
```

**5. Handle mouse motion when tracking**
```rust
// main.rs WindowEvent::CursorMoved
fn handle_cursor_moved(state: &mut WindowState, x: f32, y: f32) {
    let shell = get_active_shell(state);
    let mode = shell.terminal().inner().mode();
    
    if mode.contains(TermMode::MOUSE_MOTION) ||
       (mode.contains(TermMode::MOUSE_DRAG) && state.mouse_pressed) {
        let (col, line) = screen_to_cell(state, x, y);
        let btn = if state.mouse_pressed { 32 } else { 35 };  // Motion indicator
        let sgr = mode.contains(TermMode::SGR_MOUSE);
        let seq = mouse_report(btn, col, line, true, sgr);
        shell.send_input(&seq);
    }
}
```

**6. Handle scroll wheel**
```rust
// main.rs WindowEvent::MouseWheel
fn handle_mouse_wheel(state: &mut WindowState, delta: MouseScrollDelta) {
    let shell = get_active_shell(state);
    
    if should_report_mouse(shell) {
        let (col, line) = screen_to_cell(state, state.cursor_position);
        let btn = if delta.y > 0 { 64 } else { 65 };  // Scroll up/down
        let sgr = shell.terminal().inner().mode().contains(TermMode::SGR_MOUSE);
        let seq = mouse_report(btn, col, line, true, sgr);
        shell.send_input(&seq);
    } else {
        // Scrollback behavior (CRT-T-0049)
        shell.scroll(delta);
    }
}
```

### Files to Modify
- `crates/crt-core/src/lib.rs`: Re-export `TermMode`
- `src/main.rs`: Update mouse event handlers to check mode and report
- `src/input.rs`: Add `mouse_report()` function, `should_report_mouse()`

### Mouse Button Encoding
| Button | Code | Description |
|--------|------|-------------|
| 0 | Left click |
| 1 | Middle click |
| 2 | Right click |
| 32 | Motion with button |
| 35 | Motion no button |
| 64 | Scroll up |
| 65 | Scroll down |

### Dependencies
- alacritty_terminal `TermMode` for mode checking
- CRT-T-0049 (scrollback) - need to share wheel handling logic

### Risk Considerations
- Mode switching mid-stream: terminal enables/disables mouse mode
- Coordinate encoding limits in legacy mode (max 223)
- High-frequency motion events could flood PTY

## Status Updates
*To be added during implementation*