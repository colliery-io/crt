---
id: extract-url-detection-to-pure
level: task
title: "Extract URL detection to pure functions"
short_code: "CRT-T-0085"
created_at: 2025-11-28T14:51:29.506484+00:00
updated_at: 2025-11-28T15:30:11.803039+00:00
parent: CRT-I-0015
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Extract URL detection to pure functions

## Objective

Extract URL detection logic from `input.rs` into pure functions that can detect URLs in text without requiring window or terminal context.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/input/url_detection.rs` created with pure functions
- [ ] `detect_urls()` finds all URLs in a string with their positions
- [ ] `url_at_column()` returns URL at a specific column position
- [ ] Supports http://, https://, file://, and www. prefixes
- [ ] Returns URL bounds (start column, end column) for highlighting
- [ ] Unit tests cover various URL formats and edge cases
- [ ] Tests pass with `cargo test`

## Implementation Notes

### File: `src/input/url_detection.rs`

```rust
use regex::Regex;
use std::sync::LazyLock;

static URL_REGEX: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r#"(https?://|file://|www\.)[^\s<>\[\](){}'"`,;]+"#).unwrap()
});

#[derive(Debug, Clone, PartialEq)]
pub struct UrlMatch {
    pub url: String,
    pub start_col: usize,
    pub end_col: usize,
}

impl UrlMatch {
    /// Get the full URL (adds https:// to www. URLs)
    pub fn full_url(&self) -> String {
        if self.url.starts_with("www.") {
            format!("https://{}", self.url)
        } else {
            self.url.clone()
        }
    }
    
    /// Check if column is within this URL
    pub fn contains_column(&self, col: usize) -> bool {
        col >= self.start_col && col < self.end_col
    }
}

/// Detect all URLs in a line of text
pub fn detect_urls(text: &str) -> Vec<UrlMatch> {
    URL_REGEX
        .find_iter(text)
        .map(|m| {
            let url = m.as_str().to_string();
            // Trim trailing punctuation that's likely not part of URL
            let url = url.trim_end_matches(|c| matches!(c, '.' | ',' | ')' | ']' | '}' | ';' | ':'));
            UrlMatch {
                url: url.to_string(),
                start_col: m.start(),
                end_col: m.start() + url.len(),
            }
        })
        .collect()
}

/// Find URL at a specific column, if any
pub fn url_at_column(urls: &[UrlMatch], col: usize) -> Option<&UrlMatch> {
    urls.iter().find(|u| u.contains_column(col))
}

/// Detect URLs and return the one at the given column
pub fn detect_url_at_column(text: &str, col: usize) -> Option<UrlMatch> {
    let urls = detect_urls(text);
    url_at_column(&urls, col).cloned()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_https_url() {
        let urls = detect_urls("Visit https://example.com for more");
        assert_eq!(urls.len(), 1);
        assert_eq!(urls[0].url, "https://example.com");
        assert_eq!(urls[0].start_col, 6);
    }

    #[test]
    fn test_detect_www_url() {
        let urls = detect_urls("Go to www.example.com");
        assert_eq!(urls.len(), 1);
        assert_eq!(urls[0].full_url(), "https://www.example.com");
    }

    #[test]
    fn test_detect_file_url() {
        let urls = detect_urls("Open file:///path/to/file.txt");
        assert_eq!(urls.len(), 1);
        assert!(urls[0].url.starts_with("file://"));
    }

    #[test]
    fn test_multiple_urls() {
        let urls = detect_urls("See https://a.com and https://b.com");
        assert_eq!(urls.len(), 2);
    }

    #[test]
    fn test_url_at_column() {
        let urls = detect_urls("Visit https://example.com here");
        assert!(url_at_column(&urls, 6).is_some());
        assert!(url_at_column(&urls, 20).is_some());
        assert!(url_at_column(&urls, 0).is_none());
        assert!(url_at_column(&urls, 30).is_none());
    }

    #[test]
    fn test_trim_trailing_punctuation() {
        let urls = detect_urls("See https://example.com.");
        assert_eq!(urls[0].url, "https://example.com");
    }

    #[test]
    fn test_url_in_parentheses() {
        let urls = detect_urls("(see https://example.com)");
        assert_eq!(urls[0].url, "https://example.com");
    }

    #[test]
    fn test_no_urls() {
        let urls = detect_urls("No URLs here");
        assert!(urls.is_empty());
    }
}
```

### Source Material

Extract logic from `src/input.rs` function `detect_urls_in_line()` (around line 600-650).

### Dependencies

None - can be implemented independently.