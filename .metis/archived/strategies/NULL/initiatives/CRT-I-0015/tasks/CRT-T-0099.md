---
id: create-testterminal-wrapper-for
level: task
title: "Create TestTerminal wrapper for integration tests"
short_code: "CRT-T-0099"
created_at: 2025-11-28T14:51:56.371537+00:00
updated_at: 2025-11-29T17:20:07.902228+00:00
parent: CRT-I-0015
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Create TestTerminal wrapper for integration tests

*This template includes sections for various types of tasks. Delete sections that don't apply to your specific use case.*

## Parent Initiative **[CONDITIONAL: Assigned Task]**

[[CRT-I-0015]]

## Objective

Create a `TestTerminal` wrapper that combines `Terminal` with `FakePty`, providing a convenient API for integration testing terminal behavior.

## Backlog Item Details **[CONDITIONAL: Backlog Item]**

{Delete this section when task is assigned to an initiative}

### Type
- [ ] Bug - Production issue that needs fixing
- [ ] Feature - New functionality or enhancement  
- [ ] Tech Debt - Code improvement or refactoring
- [ ] Chore - Maintenance or setup work

### Priority
- [ ] P0 - Critical (blocks users/revenue)
- [ ] P1 - High (important for user experience)
- [ ] P2 - Medium (nice to have)
- [ ] P3 - Low (when time permits)

### Impact Assessment **[CONDITIONAL: Bug]**
- **Affected Users**: {Number/percentage of users affected}
- **Reproduction Steps**: 
  1. {Step 1}
  2. {Step 2}
  3. {Step 3}
- **Expected vs Actual**: {What should happen vs what happens}

### Business Justification **[CONDITIONAL: Feature]**
- **User Value**: {Why users need this}
- **Business Value**: {Impact on metrics/revenue}
- **Effort Estimate**: {Rough size - S/M/L/XL}

### Technical Debt Impact **[CONDITIONAL: Tech Debt]**
- **Current Problems**: {What's difficult/slow/buggy now}
- **Benefits of Fixing**: {What improves after refactoring}
- **Risk Assessment**: {Risks of not addressing this}

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `crt-core/src/test_terminal.rs` created
- [ ] `TestTerminal` wraps `Terminal` + `FakePty`
- [ ] `send()` method queues output and processes it
- [ ] `cursor_position()` returns current cursor location
- [ ] `cell_char()` and `line_content()` for grid inspection
- [ ] `assert_cursor_at()` and similar assertion helpers
- [ ] Only compiled in test builds
- [ ] Example tests demonstrate usage

## Test Cases **[CONDITIONAL: Testing Task]**

{Delete unless this is a testing task}

### Test Case 1: {Test Case Name}
- **Test ID**: TC-001
- **Preconditions**: {What must be true before testing}
- **Steps**: 
  1. {Step 1}
  2. {Step 2}
  3. {Step 3}
- **Expected Results**: {What should happen}
- **Actual Results**: {To be filled during execution}
- **Status**: {Pass/Fail/Blocked}

### Test Case 2: {Test Case Name}
- **Test ID**: TC-002
- **Preconditions**: {What must be true before testing}
- **Steps**: 
  1. {Step 1}
  2. {Step 2}
- **Expected Results**: {What should happen}
- **Actual Results**: {To be filled during execution}
- **Status**: {Pass/Fail/Blocked}

## Documentation Sections **[CONDITIONAL: Documentation Task]**

{Delete unless this is a documentation task}

### User Guide Content
- **Feature Description**: {What this feature does and why it's useful}
- **Prerequisites**: {What users need before using this feature}
- **Step-by-Step Instructions**:
  1. {Step 1 with screenshots/examples}
  2. {Step 2 with screenshots/examples}
  3. {Step 3 with screenshots/examples}

### Troubleshooting Guide
- **Common Issue 1**: {Problem description and solution}
- **Common Issue 2**: {Problem description and solution}
- **Error Messages**: {List of error messages and what they mean}

### API Documentation **[CONDITIONAL: API Documentation]**
- **Endpoint**: {API endpoint description}
- **Parameters**: {Required and optional parameters}
- **Example Request**: {Code example}
- **Example Response**: {Expected response format}

## Implementation Notes

### File: `crt-core/src/test_terminal.rs`

```rust
#[cfg(test)]
use super::{Terminal, FakePty};
use alacritty_terminal::index::{Point, Column, Line};

/// A test wrapper combining Terminal with FakePty for easy testing
#[cfg(test)]
pub struct TestTerminal {
    terminal: Terminal,
    pty: FakePty,
}

#[cfg(test)]
impl TestTerminal {
    /// Create a new test terminal with given dimensions
    pub fn new(cols: usize, rows: usize) -> Self {
        let pty = FakePty::new();
        let terminal = Terminal::new(cols, rows);
        Self { terminal, pty }
    }

    /// Send data to the terminal (simulates PTY output)
    pub fn send(&mut self, data: &str) {
        self.pty.queue_str(data);
        self.process();
    }

    /// Send raw bytes to the terminal
    pub fn send_bytes(&mut self, data: &[u8]) {
        self.pty.queue_output(data);
        self.process();
    }

    /// Send an escape sequence (without the ESC prefix)
    pub fn send_escape(&mut self, seq: &str) {
        self.pty.queue_escape(seq);
        self.process();
    }

    /// Process any pending PTY output
    fn process(&mut self) {
        while self.pty.has_pending_output() {
            let mut buf = [0u8; 1024];
            if let Ok(n) = std::io::Read::read(&mut self.pty, &mut buf) {
                if n > 0 {
                    self.terminal.process_bytes(&buf[..n]);
                }
            }
        }
    }

    /// Get current cursor position (col, row)
    pub fn cursor_position(&self) -> (usize, i32) {
        let cursor = self.terminal.cursor();
        (cursor.column.0, cursor.line.0)
    }

    /// Get the character at a specific cell
    pub fn cell_char(&self, col: usize, row: i32) -> char {
        self.terminal
            .grid()
            .get(Point::new(Line(row), Column(col)))
            .map(|cell| cell.c)
            .unwrap_or(' ')
    }

    /// Get the content of a line as a string
    pub fn line_content(&self, row: i32) -> String {
        let cols = self.terminal.cols();
        (0..cols)
            .map(|col| self.cell_char(col, row))
            .collect::<String>()
            .trim_end()
            .to_string()
    }

    /// Get all visible content as a string
    pub fn screen_content(&self) -> String {
        let rows = self.terminal.rows();
        (0..rows as i32)
            .map(|row| self.line_content(row))
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Get the terminal dimensions
    pub fn size(&self) -> (usize, usize) {
        (self.terminal.cols(), self.terminal.rows())
    }

    // Assertion helpers

    pub fn assert_cursor_at(&self, col: usize, row: i32) {
        let (actual_col, actual_row) = self.cursor_position();
        assert_eq!(
            (actual_col, actual_row),
            (col, row),
            "Expected cursor at ({}, {}), but was at ({}, {})",
            col, row, actual_col, actual_row
        );
    }

    pub fn assert_line_contains(&self, row: i32, expected: &str) {
        let content = self.line_content(row);
        assert!(
            content.contains(expected),
            "Expected line {} to contain '{}', but was '{}'",
            row, expected, content
        );
    }

    pub fn assert_cell_is(&self, col: usize, row: i32, expected: char) {
        let actual = self.cell_char(col, row);
        assert_eq!(
            actual, expected,
            "Expected cell ({}, {}) to be '{}', but was '{}'",
            col, row, expected, actual
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_text() {
        let mut t = TestTerminal::new(80, 24);
        t.send("Hello, World!");
        
        t.assert_line_contains(0, "Hello, World!");
        t.assert_cursor_at(13, 0);
    }

    #[test]
    fn test_cursor_movement() {
        let mut t = TestTerminal::new(80, 24);
        t.send("ABC");
        t.send_escape("[H"); // Cursor home
        
        t.assert_cursor_at(0, 0);
    }

    #[test]
    fn test_cursor_absolute() {
        let mut t = TestTerminal::new(80, 24);
        t.send_escape("[5;10H"); // Move to row 5, col 10
        
        // ANSI is 1-indexed, internal is 0-indexed
        t.assert_cursor_at(9, 4);
    }

    #[test]
    fn test_newline() {
        let mut t = TestTerminal::new(80, 24);
        t.send("Line 1\nLine 2");
        
        t.assert_line_contains(0, "Line 1");
        t.assert_line_contains(1, "Line 2");
    }

    #[test]
    fn test_clear_screen() {
        let mut t = TestTerminal::new(80, 24);
        t.send("Some text");
        t.send_escape("[2J"); // Clear screen
        t.send_escape("[H");  // Cursor home
        
        assert_eq!(t.line_content(0), "");
    }
}
```

### Dependencies

- CRT-T-0098 (FakePty must exist first)