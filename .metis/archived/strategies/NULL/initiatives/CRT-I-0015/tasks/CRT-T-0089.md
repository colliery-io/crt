---
id: create-uistate-aggregation-module
level: task
title: "Create UiState aggregation module"
short_code: "CRT-T-0089"
created_at: 2025-11-28T14:51:30.177294+00:00
updated_at: 2025-11-28T15:41:59.794081+00:00
parent: CRT-I-0015
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Create UiState aggregation module

## Objective

Create a `UiState` module that aggregates all UI-related state (selection, search, context menu, cursor position, URLs) into a single testable struct.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/state/ui_state.rs` created with `UiState` struct
- [ ] Aggregates `SelectionState`, `SearchState`, `ContextMenuState`
- [ ] Contains cursor position, hovered URL index, bell state
- [ ] `src/state/mod.rs` re-exports all state modules
- [ ] `lib.rs` exports the state module
- [ ] All aggregated state is accessible via `UiState`
- [ ] Code compiles with no warnings

## Implementation Notes

### File: `src/state/mod.rs`

```rust
mod selection;
mod tab_state;
mod ui_state;

pub use selection::{SelectionState, SelectionMode};
pub use tab_state::{TabState, TabInfo, TabId};
pub use ui_state::UiState;

// Re-export SearchState from existing location or move it here
pub use crate::window::SearchState;
```

### File: `src/state/ui_state.rs`

```rust
use super::{SelectionState, TabId};
use crate::input::url_detection::UrlMatch;

/// State for context menu visibility and position
#[derive(Debug, Clone, Default)]
pub struct ContextMenuState {
    pub visible: bool,
    pub position: (f32, f32),
    pub selected_index: usize,
}

impl ContextMenuState {
    pub fn show(&mut self, x: f32, y: f32) {
        self.visible = true;
        self.position = (x, y);
        self.selected_index = 0;
    }

    pub fn hide(&mut self) {
        self.visible = false;
    }

    pub fn select_next(&mut self, max_items: usize) {
        if self.selected_index < max_items - 1 {
            self.selected_index += 1;
        }
    }

    pub fn select_previous(&mut self) {
        if self.selected_index > 0 {
            self.selected_index -= 1;
        }
    }
}

/// Visual bell animation state
#[derive(Debug, Clone, Default)]
pub struct BellState {
    pub intensity: f32,
    pub active: bool,
}

impl BellState {
    pub fn trigger(&mut self) {
        self.intensity = 1.0;
        self.active = true;
    }

    pub fn update(&mut self, dt: f32) {
        if self.active {
            self.intensity -= dt * 4.0; // Fade over ~250ms
            if self.intensity <= 0.0 {
                self.intensity = 0.0;
                self.active = false;
            }
        }
    }
}

/// Search state (may already exist, consolidate here)
#[derive(Debug, Clone, Default)]
pub struct SearchState {
    pub active: bool,
    pub query: String,
    pub matches: Vec<SearchMatch>,
    pub current_match: usize,
}

#[derive(Debug, Clone)]
pub struct SearchMatch {
    pub line: i32,
    pub start_col: usize,
    pub end_col: usize,
}

impl SearchState {
    pub fn open(&mut self) {
        self.active = true;
    }

    pub fn close(&mut self) {
        self.active = false;
        self.query.clear();
        self.matches.clear();
    }

    pub fn next_match(&mut self) {
        if !self.matches.is_empty() {
            self.current_match = (self.current_match + 1) % self.matches.len();
        }
    }

    pub fn previous_match(&mut self) {
        if !self.matches.is_empty() {
            self.current_match = if self.current_match == 0 {
                self.matches.len() - 1
            } else {
                self.current_match - 1
            };
        }
    }
}

/// Aggregated UI state for a window
#[derive(Debug, Default)]
pub struct UiState {
    /// Text selection state
    pub selection: SelectionState,
    
    /// Search/find state
    pub search: SearchState,
    
    /// Right-click context menu
    pub context_menu: ContextMenuState,
    
    /// Visual bell animation
    pub bell: BellState,
    
    /// Current mouse cursor position in pixels
    pub cursor_position: (f32, f32),
    
    /// Detected URLs in the current view
    pub detected_urls: Vec<UrlMatch>,
    
    /// Index of URL currently hovered, if any
    pub hovered_url_index: Option<usize>,
    
    /// Whether the window content needs redraw
    pub dirty: bool,
}

impl UiState {
    pub fn new() -> Self {
        Self::default()
    }

    /// Mark the view as needing redraw
    pub fn invalidate(&mut self) {
        self.dirty = true;
    }

    /// Clear the dirty flag after redraw
    pub fn mark_clean(&mut self) {
        self.dirty = false;
    }

    /// Update cursor position and check for URL hover
    pub fn update_cursor(&mut self, x: f32, y: f32, col: usize) {
        self.cursor_position = (x, y);
        self.hovered_url_index = self.detected_urls
            .iter()
            .position(|u| u.contains_column(col));
    }

    /// Get the currently hovered URL, if any
    pub fn hovered_url(&self) -> Option<&UrlMatch> {
        self.hovered_url_index
            .and_then(|i| self.detected_urls.get(i))
    }
}
```

### Dependencies

- CRT-T-0087 (SelectionState)
- CRT-T-0085 (UrlMatch from url_detection)

### Notes

- This consolidates scattered UI state from `WindowState`
- `SearchState` may already exist - consolidate or re-export
- `BellState` and `ContextMenuState` are simple enough to inline