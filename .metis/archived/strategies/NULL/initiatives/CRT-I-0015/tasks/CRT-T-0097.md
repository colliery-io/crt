---
id: create-layout-text-layout-module
level: task
title: "Create layout/text_layout module with tests"
short_code: "CRT-T-0097"
created_at: 2025-11-28T14:51:47.418738+00:00
updated_at: 2025-11-29T17:20:11.101769+00:00
parent: CRT-I-0015
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Create layout/text_layout module with tests

*This template includes sections for various types of tasks. Delete sections that don't apply to your specific use case.*

## Parent Initiative **[CONDITIONAL: Assigned Task]**

[[CRT-I-0015]]

## Objective

Create a `layout/text_layout` module with pure functions for converting grid positions to pixel coordinates and laying out text for rendering.

## Backlog Item Details **[CONDITIONAL: Backlog Item]**

{Delete this section when task is assigned to an initiative}

### Type
- [ ] Bug - Production issue that needs fixing
- [ ] Feature - New functionality or enhancement  
- [ ] Tech Debt - Code improvement or refactoring
- [ ] Chore - Maintenance or setup work

### Priority
- [ ] P0 - Critical (blocks users/revenue)
- [ ] P1 - High (important for user experience)
- [ ] P2 - Medium (nice to have)
- [ ] P3 - Low (when time permits)

### Impact Assessment **[CONDITIONAL: Bug]**
- **Affected Users**: {Number/percentage of users affected}
- **Reproduction Steps**: 
  1. {Step 1}
  2. {Step 2}
  3. {Step 3}
- **Expected vs Actual**: {What should happen vs what happens}

### Business Justification **[CONDITIONAL: Feature]**
- **User Value**: {Why users need this}
- **Business Value**: {Impact on metrics/revenue}
- **Effort Estimate**: {Rough size - S/M/L/XL}

### Technical Debt Impact **[CONDITIONAL: Tech Debt]**
- **Current Problems**: {What's difficult/slow/buggy now}
- **Benefits of Fixing**: {What improves after refactoring}
- **Risk Assessment**: {Risks of not addressing this}

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/layout/text_layout.rs` created
- [ ] `src/layout/mod.rs` re-exports all layout modules
- [ ] `cell_to_pixel()` and `pixel_to_cell()` functions
- [ ] `layout_line()` positions characters for rendering
- [ ] Handles wide characters (CJK, emoji)
- [ ] Unit tests verify coordinate transformations
- [ ] Tests pass with `cargo test`

## Test Cases **[CONDITIONAL: Testing Task]**

{Delete unless this is a testing task}

### Test Case 1: {Test Case Name}
- **Test ID**: TC-001
- **Preconditions**: {What must be true before testing}
- **Steps**: 
  1. {Step 1}
  2. {Step 2}
  3. {Step 3}
- **Expected Results**: {What should happen}
- **Actual Results**: {To be filled during execution}
- **Status**: {Pass/Fail/Blocked}

### Test Case 2: {Test Case Name}
- **Test ID**: TC-002
- **Preconditions**: {What must be true before testing}
- **Steps**: 
  1. {Step 1}
  2. {Step 2}
- **Expected Results**: {What should happen}
- **Actual Results**: {To be filled during execution}
- **Status**: {Pass/Fail/Blocked}

## Documentation Sections **[CONDITIONAL: Documentation Task]**

{Delete unless this is a documentation task}

### User Guide Content
- **Feature Description**: {What this feature does and why it's useful}
- **Prerequisites**: {What users need before using this feature}
- **Step-by-Step Instructions**:
  1. {Step 1 with screenshots/examples}
  2. {Step 2 with screenshots/examples}
  3. {Step 3 with screenshots/examples}

### Troubleshooting Guide
- **Common Issue 1**: {Problem description and solution}
- **Common Issue 2**: {Problem description and solution}
- **Error Messages**: {List of error messages and what they mean}

### API Documentation **[CONDITIONAL: API Documentation]**
- **Endpoint**: {API endpoint description}
- **Parameters**: {Required and optional parameters}
- **Example Request**: {Code example}
- **Example Response**: {Expected response format}

## Implementation Notes

### File: `src/layout/mod.rs`

```rust
mod cell_metrics;
mod text_layout;

pub use cell_metrics::{CellMetrics, Padding, WindowSize, TerminalSize, ContentArea};
pub use text_layout::{cell_to_pixel, pixel_to_cell, LayoutGlyph, layout_line};
```

### File: `src/layout/text_layout.rs`

```rust
use super::{CellMetrics, ContentArea};
use alacritty_terminal::index::{Point, Column, Line};

/// A positioned glyph ready for rendering
#[derive(Debug, Clone)]
pub struct LayoutGlyph {
    pub character: char,
    pub x: f32,
    pub y: f32,
    pub width: f32,  // May be 2x for wide chars
    pub cell_index: usize,
}

/// Convert a grid cell position to pixel coordinates
pub fn cell_to_pixel(
    point: Point,
    metrics: &CellMetrics,
    content_area: &ContentArea,
) -> (f32, f32) {
    let x = content_area.x + (point.column.0 as f32 * metrics.cell_width);
    let y = content_area.y + (point.line.0 as f32 * metrics.cell_height);
    (x, y)
}

/// Convert pixel coordinates to grid cell position
pub fn pixel_to_cell(
    x: f32,
    y: f32,
    metrics: &CellMetrics,
    content_area: &ContentArea,
) -> Option<Point> {
    // Check if within content area
    if x < content_area.x || y < content_area.y {
        return None;
    }
    if x >= content_area.x + content_area.width || y >= content_area.y + content_area.height {
        return None;
    }
    
    let col = ((x - content_area.x) / metrics.cell_width).floor() as usize;
    let row = ((y - content_area.y) / metrics.cell_height).floor() as i32;
    
    Some(Point::new(Line(row), Column(col)))
}

/// Check if a character is wide (takes 2 cells)
pub fn is_wide_char(c: char) -> bool {
    use unicode_width::UnicodeWidthChar;
    c.width().unwrap_or(1) > 1
}

/// Layout a line of text into positioned glyphs
pub fn layout_line(
    line: &str,
    row: i32,
    metrics: &CellMetrics,
    content_area: &ContentArea,
) -> Vec<LayoutGlyph> {
    let mut glyphs = Vec::new();
    let mut col = 0usize;
    
    for c in line.chars() {
        let x = content_area.x + (col as f32 * metrics.cell_width);
        let y = content_area.y + (row as f32 * metrics.cell_height);
        
        let width = if is_wide_char(c) {
            metrics.cell_width * 2.0
        } else {
            metrics.cell_width
        };
        
        glyphs.push(LayoutGlyph {
            character: c,
            x,
            y,
            width,
            cell_index: col,
        });
        
        // Advance by character width
        col += if is_wide_char(c) { 2 } else { 1 };
    }
    
    glyphs
}

/// Calculate the bounding rectangle for a range of cells
pub fn cell_range_rect(
    start: Point,
    end: Point,
    metrics: &CellMetrics,
    content_area: &ContentArea,
) -> (f32, f32, f32, f32) {
    let (x1, y1) = cell_to_pixel(start, metrics, content_area);
    let (x2, y2) = cell_to_pixel(end, metrics, content_area);
    
    let x = x1.min(x2);
    let y = y1.min(y2);
    let width = (x2 - x1).abs() + metrics.cell_width;
    let height = (y2 - y1).abs() + metrics.cell_height;
    
    (x, y, width, height)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::layout::Padding;

    fn test_setup() -> (CellMetrics, ContentArea) {
        let metrics = CellMetrics::new(10.0, 20.0, Padding::uniform(5.0), 0.0);
        let content = ContentArea { x: 5.0, y: 5.0, width: 800.0, height: 480.0 };
        (metrics, content)
    }

    #[test]
    fn test_cell_to_pixel() {
        let (metrics, content) = test_setup();
        
        let (x, y) = cell_to_pixel(Point::new(Line(0), Column(0)), &metrics, &content);
        assert_eq!((x, y), (5.0, 5.0));
        
        let (x, y) = cell_to_pixel(Point::new(Line(2), Column(5)), &metrics, &content);
        assert_eq!((x, y), (55.0, 45.0)); // 5 + 5*10, 5 + 2*20
    }

    #[test]
    fn test_pixel_to_cell() {
        let (metrics, content) = test_setup();
        
        let point = pixel_to_cell(15.0, 25.0, &metrics, &content);
        assert_eq!(point, Some(Point::new(Line(1), Column(1))));
        
        // Outside content area
        let point = pixel_to_cell(0.0, 0.0, &metrics, &content);
        assert_eq!(point, None);
    }

    #[test]
    fn test_layout_line() {
        let (metrics, content) = test_setup();
        
        let glyphs = layout_line("Hello", 0, &metrics, &content);
        
        assert_eq!(glyphs.len(), 5);
        assert_eq!(glyphs[0].character, 'H');
        assert_eq!(glyphs[0].x, 5.0);
        assert_eq!(glyphs[4].character, 'o');
        assert_eq!(glyphs[4].x, 45.0); // 5 + 4*10
    }

    #[test]
    fn test_wide_char_layout() {
        let (metrics, content) = test_setup();
        
        // CJK character takes 2 cells
        let glyphs = layout_line("A\u{4E2D}B", 0, &metrics, &content);
        
        assert_eq!(glyphs.len(), 3);
        assert_eq!(glyphs[0].cell_index, 0);
        assert_eq!(glyphs[1].cell_index, 1); // Wide char at col 1
        assert_eq!(glyphs[1].width, 20.0);   // 2x width
        assert_eq!(glyphs[2].cell_index, 3); // B at col 3 (skipped col 2)
    }
}
```

### Dependencies

- CRT-T-0096 (CellMetrics must exist first)
- Add `unicode-width` crate for wide char detection