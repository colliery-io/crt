---
id: extract-mouse-input-to-pure
level: task
title: "Extract mouse input to pure functions"
short_code: "CRT-T-0086"
created_at: 2025-11-28T14:51:29.647188+00:00
updated_at: 2025-11-28T15:33:38.754407+00:00
parent: CRT-I-0015
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Extract mouse input to pure functions

## Objective

Extract mouse input handling into pure functions for grid position calculation, selection range computation, and click detection.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/input/mouse.rs` created with pure functions
- [ ] `pixel_to_cell()` converts screen coordinates to grid position
- [ ] `cell_to_pixel()` converts grid position to screen coordinates
- [ ] `expand_selection()` handles word/line expansion for double/triple click
- [ ] `selection_to_range()` converts start/end points to ordered range
- [ ] Functions work with configurable cell metrics (width, height, padding)
- [ ] Unit tests cover coordinate conversion and selection logic
- [ ] Tests pass with `cargo test`

## Implementation Notes

### File: `src/input/mouse.rs`

```rust
use alacritty_terminal::index::{Point, Column, Line};

/// Cell size and positioning metrics
#[derive(Debug, Clone, Copy)]
pub struct CellMetrics {
    pub cell_width: f32,
    pub cell_height: f32,
    pub padding_left: f32,
    pub padding_top: f32,
}

impl CellMetrics {
    pub fn new(cell_width: f32, cell_height: f32, padding: f32) -> Self {
        Self {
            cell_width,
            cell_height,
            padding_left: padding,
            padding_top: padding,
        }
    }
}

/// Convert pixel coordinates to grid cell position
pub fn pixel_to_cell(x: f32, y: f32, metrics: &CellMetrics) -> Point {
    let col = ((x - metrics.padding_left) / metrics.cell_width)
        .max(0.0)
        .floor() as usize;
    let row = ((y - metrics.padding_top) / metrics.cell_height)
        .max(0.0)
        .floor() as i32;
    
    Point::new(Line(row), Column(col))
}

/// Convert grid cell to pixel coordinates (top-left of cell)
pub fn cell_to_pixel(point: Point, metrics: &CellMetrics) -> (f32, f32) {
    let x = metrics.padding_left + (point.column.0 as f32 * metrics.cell_width);
    let y = metrics.padding_top + (point.line.0 as f32 * metrics.cell_height);
    (x, y)
}

/// Check if a point is within the terminal grid area
pub fn is_in_grid(x: f32, y: f32, metrics: &CellMetrics, cols: usize, rows: usize) -> bool {
    let grid_width = metrics.padding_left + (cols as f32 * metrics.cell_width);
    let grid_height = metrics.padding_top + (rows as f32 * metrics.cell_height);
    
    x >= metrics.padding_left && x < grid_width &&
    y >= metrics.padding_top && y < grid_height
}

/// Selection range with ordered start/end
#[derive(Debug, Clone, PartialEq)]
pub struct SelectionRange {
    pub start: Point,
    pub end: Point,
}

impl SelectionRange {
    /// Create ordered range (start always before end)
    pub fn new(a: Point, b: Point) -> Self {
        if a.line < b.line || (a.line == b.line && a.column <= b.column) {
            Self { start: a, end: b }
        } else {
            Self { start: b, end: a }
        }
    }
    
    /// Check if a point is within this selection
    pub fn contains(&self, point: Point) -> bool {
        if point.line < self.start.line || point.line > self.end.line {
            return false;
        }
        if point.line == self.start.line && point.column < self.start.column {
            return false;
        }
        if point.line == self.end.line && point.column > self.end.column {
            return false;
        }
        true
    }
}

/// Expand a point to word boundaries
/// Returns (start_col, end_col) for the word at the given position
pub fn expand_to_word(line_content: &str, col: usize) -> (usize, usize) {
    if col >= line_content.len() {
        return (col, col);
    }
    
    let chars: Vec<char> = line_content.chars().collect();
    let is_word_char = |c: char| c.is_alphanumeric() || c == '_';
    
    // Find start of word
    let mut start = col;
    while start > 0 && is_word_char(chars[start - 1]) {
        start -= 1;
    }
    
    // Find end of word
    let mut end = col;
    while end < chars.len() && is_word_char(chars[end]) {
        end += 1;
    }
    
    (start, end)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn metrics() -> CellMetrics {
        CellMetrics::new(10.0, 20.0, 5.0)
    }

    #[test]
    fn test_pixel_to_cell_origin() {
        let m = metrics();
        let p = pixel_to_cell(5.0, 5.0, &m);
        assert_eq!(p, Point::new(Line(0), Column(0)));
    }

    #[test]
    fn test_pixel_to_cell_offset() {
        let m = metrics();
        // x=25 -> (25-5)/10 = 2, y=45 -> (45-5)/20 = 2
        let p = pixel_to_cell(25.0, 45.0, &m);
        assert_eq!(p, Point::new(Line(2), Column(2)));
    }

    #[test]
    fn test_cell_to_pixel() {
        let m = metrics();
        let (x, y) = cell_to_pixel(Point::new(Line(1), Column(3)), &m);
        assert_eq!(x, 35.0); // 5 + 3*10
        assert_eq!(y, 25.0); // 5 + 1*20
    }

    #[test]
    fn test_selection_range_ordering() {
        let a = Point::new(Line(5), Column(10));
        let b = Point::new(Line(2), Column(5));
        let range = SelectionRange::new(a, b);
        assert_eq!(range.start, b);
        assert_eq!(range.end, a);
    }

    #[test]
    fn test_expand_to_word() {
        let line = "hello world test";
        assert_eq!(expand_to_word(line, 7), (6, 11)); // "world"
        assert_eq!(expand_to_word(line, 0), (0, 5));  // "hello"
    }

    #[test]
    fn test_is_in_grid() {
        let m = metrics();
        assert!(is_in_grid(10.0, 10.0, &m, 80, 24));
        assert!(!is_in_grid(0.0, 0.0, &m, 80, 24)); // In padding
    }
}
```

### Source Material

Extract logic from `src/input.rs`:
- Coordinate conversion around line 300-350
- Selection handling around line 400-500

### Dependencies

None - can be implemented independently.