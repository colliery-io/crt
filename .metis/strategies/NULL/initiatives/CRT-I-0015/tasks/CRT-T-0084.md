---
id: extract-keyboard-input-to-pure
level: task
title: "Extract keyboard input to pure functions"
short_code: "CRT-T-0084"
created_at: 2025-11-28T14:51:29.387951+00:00
updated_at: 2025-11-28T15:30:11.723891+00:00
parent: CRT-I-0015
blocked_by: []
archived: false

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Extract keyboard input to pure functions

## Objective

Extract keyboard input handling from `input.rs` into pure functions that take key events and return `Command` values, enabling unit testing without window/terminal context.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/input/keyboard.rs` created with pure functions
- [ ] `key_to_terminal_bytes()` converts keys to PTY byte sequences
- [ ] `is_shortcut()` identifies app-level shortcuts (Cmd+C, Cmd+V, etc.)
- [ ] `shortcut_to_command()` maps shortcuts to Commands
- [ ] All functions are pure (no side effects, no mutable external state)
- [ ] Unit tests cover common keys, modifiers, and edge cases
- [ ] Tests pass with `cargo test`

## Implementation Notes

### File: `src/input/keyboard.rs`

```rust
use winit::keyboard::{Key, NamedKey, ModifiersState};
use alacritty_terminal::term::TerminalMode;
use super::Command;

/// Convert a key press to terminal byte sequence
/// Returns None if the key should not be sent to PTY
pub fn key_to_terminal_bytes(
    key: &Key,
    modifiers: ModifiersState,
    mode: TerminalMode,
) -> Option<Vec<u8>> {
    match key {
        Key::Character(c) => {
            // Handle Ctrl+letter combinations
            if modifiers.control_key() && c.len() == 1 {
                let ch = c.chars().next()?;
                if ch.is_ascii_alphabetic() {
                    // Ctrl+A = 0x01, Ctrl+B = 0x02, etc.
                    let ctrl_code = (ch.to_ascii_lowercase() as u8) - b'a' + 1;
                    return Some(vec![ctrl_code]);
                }
            }
            Some(c.as_bytes().to_vec())
        }
        Key::Named(named) => named_key_to_bytes(named, modifiers, mode),
        _ => None,
    }
}

fn named_key_to_bytes(
    key: &NamedKey,
    modifiers: ModifiersState,
    mode: TerminalMode,
) -> Option<Vec<u8>> {
    // Extract from existing handle_shell_input logic
    match key {
        NamedKey::Enter => Some(vec![b'\r']),
        NamedKey::Backspace => Some(vec![0x7f]),
        NamedKey::Tab => Some(vec![b'\t']),
        NamedKey::Escape => Some(vec![0x1b]),
        NamedKey::ArrowUp => Some(b"\x1b[A".to_vec()),
        NamedKey::ArrowDown => Some(b"\x1b[B".to_vec()),
        NamedKey::ArrowRight => Some(b"\x1b[C".to_vec()),
        NamedKey::ArrowLeft => Some(b"\x1b[D".to_vec()),
        // ... more keys from input.rs
        _ => None,
    }
}

/// Check if key combination is an application shortcut
pub fn is_shortcut(key: &Key, modifiers: ModifiersState) -> bool {
    if !modifiers.super_key() { return false; }
    matches!(key,
        Key::Character(c) if matches!(c.as_str(), "c" | "v" | "f" | "n" | "t" | "w" | "+" | "-" | "0")
    )
}

/// Convert shortcut to Command
pub fn shortcut_to_command(key: &Key, modifiers: ModifiersState) -> Option<Command> {
    if !modifiers.super_key() { return None; }
    
    match key {
        Key::Character(c) => match c.as_str() {
            "c" => Some(Command::Copy(String::new())), // Actual text filled by caller
            "v" => Some(Command::Paste),
            "f" => Some(Command::OpenSearch),
            "n" => Some(Command::NewWindow),
            "t" => Some(Command::NewTab),
            "w" => Some(Command::CloseCurrentTab),
            "+" | "=" => Some(Command::AdjustFontScale(0.1)),
            "-" => Some(Command::AdjustFontScale(-0.1)),
            "0" => Some(Command::ResetFontScale),
            _ => None,
        },
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_enter_key() {
        let key = Key::Named(NamedKey::Enter);
        let result = key_to_terminal_bytes(&key, ModifiersState::empty(), TerminalMode::empty());
        assert_eq!(result, Some(vec![b'\r']));
    }

    #[test]
    fn test_ctrl_c() {
        let key = Key::Character("c".into());
        let mods = ModifiersState::CONTROL;
        let result = key_to_terminal_bytes(&key, mods, TerminalMode::empty());
        assert_eq!(result, Some(vec![0x03])); // ETX
    }

    #[test]
    fn test_cmd_c_is_shortcut() {
        let key = Key::Character("c".into());
        let mods = ModifiersState::SUPER;
        assert!(is_shortcut(&key, mods));
    }

    #[test]
    fn test_regular_c_not_shortcut() {
        let key = Key::Character("c".into());
        assert!(!is_shortcut(&key, ModifiersState::empty()));
    }
}
```

### Source Material

Extract logic from `src/input.rs` function `handle_shell_input()` (around line 50-200).

### Dependencies

- CRT-T-0083 (Command enum must exist first)