---
id: create-tabstate-module-with-tests
level: task
title: "Create TabState module with tests"
short_code: "CRT-T-0088"
created_at: 2025-11-28T14:51:29.981809+00:00
updated_at: 2025-11-28T15:39:21.008079+00:00
parent: CRT-I-0015
blocked_by: []
archived: false

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Create TabState module with tests

## Objective

Create a standalone `TabState` module that manages tab list, active tab, and tab operations without requiring window or GPU context.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/state/tab_state.rs` created with `TabState` struct
- [ ] `TabInfo` struct contains tab metadata (id, title, has_activity)
- [ ] `add_tab()`, `close_tab()`, `switch_to()` methods implemented
- [ ] `next_tab()`, `previous_tab()` for keyboard navigation
- [ ] Tab ID generation is deterministic for testing
- [ ] Handles edge cases (close last tab, switch to invalid tab)
- [ ] Unit tests cover all operations
- [ ] Tests pass with `cargo test`

## Implementation Notes

### File: `src/state/tab_state.rs`

```rust
/// Unique identifier for a tab
pub type TabId = u64;

/// Metadata about a single tab (no GPU resources)
#[derive(Debug, Clone)]
pub struct TabInfo {
    pub id: TabId,
    pub title: String,
    pub has_activity: bool,
}

impl TabInfo {
    pub fn new(id: TabId, title: impl Into<String>) -> Self {
        Self {
            id,
            title: title.into(),
            has_activity: false,
        }
    }
}

/// Manages tab list and active tab selection
#[derive(Debug)]
pub struct TabState {
    tabs: Vec<TabInfo>,
    active_index: usize,
    next_id: TabId,
}

impl Default for TabState {
    fn default() -> Self {
        Self::new()
    }
}

impl TabState {
    pub fn new() -> Self {
        Self {
            tabs: Vec::new(),
            active_index: 0,
            next_id: 1,
        }
    }

    /// Create with a custom starting ID (useful for testing)
    pub fn with_start_id(start_id: TabId) -> Self {
        Self {
            tabs: Vec::new(),
            active_index: 0,
            next_id: start_id,
        }
    }

    /// Add a new tab and return its ID
    pub fn add_tab(&mut self, title: impl Into<String>) -> TabId {
        let id = self.next_id;
        self.next_id += 1;
        self.tabs.push(TabInfo::new(id, title));
        id
    }

    /// Add a tab and make it active
    pub fn add_tab_and_activate(&mut self, title: impl Into<String>) -> TabId {
        let id = self.add_tab(title);
        self.switch_to(id);
        id
    }

    /// Close a tab by ID, returns the closed tab info if found
    pub fn close_tab(&mut self, id: TabId) -> Option<TabInfo> {
        let index = self.tabs.iter().position(|t| t.id == id)?;
        let tab = self.tabs.remove(index);
        
        // Adjust active index if needed
        if self.tabs.is_empty() {
            self.active_index = 0;
        } else if index <= self.active_index && self.active_index > 0 {
            self.active_index -= 1;
        } else if self.active_index >= self.tabs.len() {
            self.active_index = self.tabs.len() - 1;
        }
        
        Some(tab)
    }

    /// Switch to a tab by ID, returns true if successful
    pub fn switch_to(&mut self, id: TabId) -> bool {
        if let Some(index) = self.tabs.iter().position(|t| t.id == id) {
            self.active_index = index;
            true
        } else {
            false
        }
    }

    /// Switch to the next tab (wraps around)
    pub fn next_tab(&mut self) {
        if !self.tabs.is_empty() {
            self.active_index = (self.active_index + 1) % self.tabs.len();
        }
    }

    /// Switch to the previous tab (wraps around)
    pub fn previous_tab(&mut self) {
        if !self.tabs.is_empty() {
            self.active_index = if self.active_index == 0 {
                self.tabs.len() - 1
            } else {
                self.active_index - 1
            };
        }
    }

    /// Get the currently active tab
    pub fn active(&self) -> Option<&TabInfo> {
        self.tabs.get(self.active_index)
    }

    /// Get the active tab ID
    pub fn active_id(&self) -> Option<TabId> {
        self.active().map(|t| t.id)
    }

    /// Get all tabs
    pub fn tabs(&self) -> &[TabInfo] {
        &self.tabs
    }

    /// Get tab count
    pub fn len(&self) -> usize {
        self.tabs.len()
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.tabs.is_empty()
    }

    /// Update a tab's title
    pub fn set_title(&mut self, id: TabId, title: impl Into<String>) {
        if let Some(tab) = self.tabs.iter_mut().find(|t| t.id == id) {
            tab.title = title.into();
        }
    }

    /// Mark a tab as having activity (for visual indicator)
    pub fn set_activity(&mut self, id: TabId, has_activity: bool) {
        if let Some(tab) = self.tabs.iter_mut().find(|t| t.id == id) {
            tab.has_activity = has_activity;
        }
    }

    /// Get the active tab index
    pub fn active_index(&self) -> usize {
        self.active_index
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_tab() {
        let mut state = TabState::new();
        let id = state.add_tab("Tab 1");
        
        assert_eq!(state.len(), 1);
        assert_eq!(state.tabs()[0].title, "Tab 1");
        assert_eq!(id, 1);
    }

    #[test]
    fn test_add_multiple_tabs() {
        let mut state = TabState::new();
        let id1 = state.add_tab("Tab 1");
        let id2 = state.add_tab("Tab 2");
        let id3 = state.add_tab("Tab 3");
        
        assert_eq!(state.len(), 3);
        assert_eq!(id1, 1);
        assert_eq!(id2, 2);
        assert_eq!(id3, 3);
    }

    #[test]
    fn test_switch_tab() {
        let mut state = TabState::new();
        let id1 = state.add_tab("Tab 1");
        let id2 = state.add_tab("Tab 2");
        
        state.switch_to(id2);
        assert_eq!(state.active_id(), Some(id2));
        
        state.switch_to(id1);
        assert_eq!(state.active_id(), Some(id1));
    }

    #[test]
    fn test_close_active_tab() {
        let mut state = TabState::new();
        let id1 = state.add_tab("Tab 1");
        let id2 = state.add_tab("Tab 2");
        state.switch_to(id2);
        
        state.close_tab(id2);
        
        assert_eq!(state.len(), 1);
        assert_eq!(state.active_id(), Some(id1));
    }

    #[test]
    fn test_close_tab_before_active() {
        let mut state = TabState::new();
        let id1 = state.add_tab("Tab 1");
        let id2 = state.add_tab("Tab 2");
        state.switch_to(id2);
        
        state.close_tab(id1);
        
        assert_eq!(state.active_id(), Some(id2));
        assert_eq!(state.active_index(), 0); // Index adjusted
    }

    #[test]
    fn test_next_previous_tab() {
        let mut state = TabState::new();
        state.add_tab("Tab 1");
        state.add_tab("Tab 2");
        state.add_tab("Tab 3");
        
        assert_eq!(state.active_index(), 0);
        
        state.next_tab();
        assert_eq!(state.active_index(), 1);
        
        state.next_tab();
        assert_eq!(state.active_index(), 2);
        
        state.next_tab(); // Wraps to 0
        assert_eq!(state.active_index(), 0);
        
        state.previous_tab(); // Wraps to 2
        assert_eq!(state.active_index(), 2);
    }

    #[test]
    fn test_empty_state() {
        let state = TabState::new();
        assert!(state.is_empty());
        assert!(state.active().is_none());
        assert!(state.active_id().is_none());
    }
}
```

### Dependencies

None - can be implemented independently.

### Notes

- Tab IDs match existing `u64` type used in `shells: HashMap<u64, ShellTerminal>`
- This replaces the `active_tab_id` and `tabs` Vec scattered in `WindowState`