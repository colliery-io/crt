---
id: create-selectionstate-module-with
level: task
title: "Create SelectionState module with tests"
short_code: "CRT-T-0087"
created_at: 2025-11-28T14:51:29.817138+00:00
updated_at: 2025-11-28T15:36:49.383132+00:00
parent: CRT-I-0015
blocked_by: []
archived: false

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0015
---

# Create SelectionState module with tests

## Objective

Create a standalone `SelectionState` module that encapsulates all selection logic (start, update, finish, clear) in a testable struct without GPU or window dependencies.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] `src/state/selection.rs` created with `SelectionState` struct
- [ ] Supports simple, word, line, and block selection modes
- [ ] `start()`, `update()`, `finish()`, `clear()` methods implemented
- [ ] `to_ranges()` returns selection ranges for rendering
- [ ] `get_selected_text()` extracts text from a grid reference
- [ ] State is fully testable without terminal/window context
- [ ] Unit tests cover all selection modes and edge cases
- [ ] Tests pass with `cargo test`

## Implementation Notes

### File: `src/state/selection.rs`

```rust
use alacritty_terminal::index::{Point, Column, Line};
use alacritty_terminal::term::Term;
use alacritty_terminal::event::EventListener;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SelectionMode {
    Simple,
    Word,
    Line,
    Block,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SelectionState {
    None,
    Selecting {
        start: Point,
        end: Point,
        mode: SelectionMode,
    },
    Selected {
        start: Point,
        end: Point,
        mode: SelectionMode,
    },
}

impl Default for SelectionState {
    fn default() -> Self {
        Self::None
    }
}

impl SelectionState {
    pub fn new() -> Self {
        Self::None
    }

    /// Start a new selection at the given point
    pub fn start(&mut self, point: Point, mode: SelectionMode) {
        *self = Self::Selecting {
            start: point,
            end: point,
            mode,
        };
    }

    /// Update the selection endpoint (during drag)
    pub fn update(&mut self, point: Point) {
        if let Self::Selecting { start, mode, .. } = *self {
            *self = Self::Selecting {
                start,
                end: point,
                mode,
            };
        }
    }

    /// Finish the selection (on mouse up)
    pub fn finish(&mut self) {
        if let Self::Selecting { start, end, mode } = *self {
            if start == end {
                // Single click, no actual selection
                *self = Self::None;
            } else {
                *self = Self::Selected { start, end, mode };
            }
        }
    }

    /// Clear any selection
    pub fn clear(&mut self) {
        *self = Self::None;
    }

    /// Check if there's an active selection
    pub fn is_active(&self) -> bool {
        !matches!(self, Self::None)
    }

    /// Check if currently selecting (mouse down)
    pub fn is_selecting(&self) -> bool {
        matches!(self, Self::Selecting { .. })
    }

    /// Get ordered start/end points (start always before end)
    pub fn ordered_bounds(&self) -> Option<(Point, Point)> {
        match *self {
            Self::None => None,
            Self::Selecting { start, end, .. } | Self::Selected { start, end, .. } => {
                Some(Self::order_points(start, end))
            }
        }
    }

    fn order_points(a: Point, b: Point) -> (Point, Point) {
        if a.line < b.line || (a.line == b.line && a.column <= b.column) {
            (a, b)
        } else {
            (b, a)
        }
    }

    /// Get the selection mode
    pub fn mode(&self) -> Option<SelectionMode> {
        match *self {
            Self::None => None,
            Self::Selecting { mode, .. } | Self::Selected { mode, .. } => Some(mode),
        }
    }

    /// Get selected text from a terminal grid
    /// This is the only method that requires terminal access
    pub fn get_text<T: EventListener>(&self, term: &Term<T>) -> Option<String> {
        let (start, end) = self.ordered_bounds()?;
        // Extract text from terminal grid between start and end
        // Implementation depends on alacritty_terminal API
        Some(term.bounds_to_string(start, end))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_initial_state() {
        let state = SelectionState::new();
        assert!(!state.is_active());
        assert!(!state.is_selecting());
    }

    #[test]
    fn test_start_selection() {
        let mut state = SelectionState::new();
        let point = Point::new(Line(5), Column(10));
        state.start(point, SelectionMode::Simple);
        
        assert!(state.is_active());
        assert!(state.is_selecting());
        assert_eq!(state.mode(), Some(SelectionMode::Simple));
    }

    #[test]
    fn test_update_selection() {
        let mut state = SelectionState::new();
        let start = Point::new(Line(5), Column(10));
        let end = Point::new(Line(5), Column(20));
        
        state.start(start, SelectionMode::Simple);
        state.update(end);
        
        let bounds = state.ordered_bounds().unwrap();
        assert_eq!(bounds, (start, end));
    }

    #[test]
    fn test_finish_selection() {
        let mut state = SelectionState::new();
        let start = Point::new(Line(5), Column(10));
        let end = Point::new(Line(5), Column(20));
        
        state.start(start, SelectionMode::Simple);
        state.update(end);
        state.finish();
        
        assert!(state.is_active());
        assert!(!state.is_selecting());
    }

    #[test]
    fn test_single_click_clears() {
        let mut state = SelectionState::new();
        let point = Point::new(Line(5), Column(10));
        
        state.start(point, SelectionMode::Simple);
        state.finish(); // No movement = no selection
        
        assert!(!state.is_active());
    }

    #[test]
    fn test_clear_selection() {
        let mut state = SelectionState::new();
        state.start(Point::new(Line(0), Column(0)), SelectionMode::Simple);
        state.update(Point::new(Line(1), Column(5)));
        state.clear();
        
        assert!(!state.is_active());
    }

    #[test]
    fn test_reverse_selection_ordering() {
        let mut state = SelectionState::new();
        let start = Point::new(Line(10), Column(20)); // Later point
        let end = Point::new(Line(5), Column(10));    // Earlier point
        
        state.start(start, SelectionMode::Simple);
        state.update(end);
        
        let (ordered_start, ordered_end) = state.ordered_bounds().unwrap();
        assert_eq!(ordered_start, end);  // Earlier point is start
        assert_eq!(ordered_end, start);  // Later point is end
    }
}
```

### Dependencies

None - can be implemented independently.

### Notes

- The `get_text()` method is the only one requiring terminal access
- All other methods are pure state manipulation
- Consider making `bounds_to_string` a trait for easier testing