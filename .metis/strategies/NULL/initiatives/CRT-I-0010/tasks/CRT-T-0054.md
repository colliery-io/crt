---
id: verify-alternate-screen-buffer
level: task
title: "Verify alternate screen buffer works for vim/less/htop"
short_code: "CRT-T-0054"
created_at: 2025-11-26T21:26:34.263606+00:00
updated_at: 2025-11-27T00:07:38.982479+00:00
parent: CRT-I-0010
blocked_by: []
archived: false

tags:
  - "#task"
  - "#phase/completed"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0010
---

# Verify alternate screen buffer works for vim/less/htop

## Parent Initiative
[[CRT-I-0010]]

## Objective
Verify that the alternate screen buffer works correctly for full-screen TUI applications like vim, less, htop, and tmux. alacritty_terminal handles this internally, but we need to verify it works and handle edge cases around selection and scrollback.

## Acceptance Criteria

## Acceptance Criteria

## Acceptance Criteria

- [ ] vim opens in full-screen mode, exits cleanly restoring previous content
- [ ] less/more show file content, q exits restoring shell
- [ ] htop displays process list correctly with live updates
- [ ] tmux creates panes and restores shell on exit
- [ ] Selection is cleared when switching to alternate screen
- [ ] Scrollback preserved on primary screen after exiting alternate

## Implementation Notes

### Current State
- alacritty_terminal handles alternate screen buffer internally via `TermMode::ALT_SCREEN`
- `renderable_content()` returns content from whichever buffer is active
- Selection may persist incorrectly across buffer switches
- Untested with actual TUI applications

### Technical Approach

**1. Test current behavior**
```bash
# Quick test commands
vim test.txt    # Should show vim UI, :q should restore shell
less README.md  # Should show file, q should restore  
htop           # Should show processes, q should restore
```

**2. Clear selection on buffer switch**
```rust
// Listen for terminal mode changes
// When ALT_SCREEN mode changes, clear selection
fn handle_terminal_events(shell: &mut ShellTerminal) {
    for event in shell.take_events() {
        match event {
            Event::ModeChange(mode) => {
                // Mode bits changed - could be alt screen toggle
                shell.clear_selection();
            }
            _ => {}
        }
    }
}
```

**3. Handle scrollback visibility**
```rust
// When on alternate screen, scrollback should not be accessible
fn can_scroll(shell: &ShellTerminal) -> bool {
    !shell.terminal().inner().mode().contains(TermMode::ALT_SCREEN)
}
```

**4. Potential issues to check**
- Screen clearing on buffer switch (smcup/rmcup sequences)
- Cursor visibility and shape preservation
- Screen size reporting during switch
- Color/style state preservation

### Testing Matrix

| Application | Feature | Expected Behavior |
|-------------|---------|-------------------|
| vim | Open file | Full screen editor, cursor visible |
| vim | :q exit | Shell restored, scrollback intact |
| vim | :split | Multiple panes render correctly |
| less | Page down | Scrolls through file |
| less | q exit | Previous shell output visible |
| htop | Live update | Process list refreshes |
| htop | F10 exit | Shell restored |
| tmux | Create pane | Split renders correctly |
| tmux | detach | Shell restored |
| man ls | Page through | Formatted output, q restores |

### Files to Modify
- `src/input.rs`: Clear selection on mode changes
- `src/window.rs`: Check for mode events in update loop
- `crates/crt-core/src/lib.rs`: May need to expose mode change detection

### Dependencies
- Re-export `TermMode::ALT_SCREEN` from crt-core
- CRT-T-0049 (scrollback) for scroll disable logic
- CRT-T-0053 (mouse reporting) often used with alt screen apps

### Risk Considerations
- Some apps may not restore screen properly (their bug, not ours)
- Rapid buffer switching could cause flicker
- Selection coordinates invalid on alternate screen

## Status Updates
*To be added during implementation*