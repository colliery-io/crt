---
id: implement-motionbehavior-system
level: task
title: "Implement MotionBehavior system (bounce, scroll, float, orbit)"
short_code: "CRT-T-0072"
created_at: 2025-11-27T14:03:59.479761+00:00
updated_at: 2025-11-27T14:03:59.479761+00:00
parent: CRT-I-0014
blocked_by: []
archived: false

tags:
  - "#task"
  - "#phase/todo"


exit_criteria_met: false
strategy_id: NULL
initiative_id: CRT-I-0014
---

# Implement MotionBehavior system (bounce, scroll, float, orbit)

*This template includes sections for various types of tasks. Delete sections that don't apply to your specific use case.*

## Parent Initiative

[[CRT-I-0014]] - Vello-Powered Backdrop Effects System

## Objective

Implement a reusable motion system that can be composed with any positional effect (ShapeEffect, SpriteEffect). Provides DVD-logo style bouncing, directional scrolling, random floating, and orbital movement.

## Acceptance Criteria

- [ ] Create `crates/crt-renderer/src/effects/motion.rs`
- [ ] Define `MotionBehavior` enum with `None`, `Bounce`, `Scroll`, `Float`, `Orbit` variants
- [ ] Implement `update(&mut self, position: &mut Vec2, bounds: Rect, dt: f32)` method
- [ ] `Bounce`: reflects velocity when hitting bounds edges
- [ ] `Scroll`: moves in direction, wraps around when exiting bounds
- [ ] `Float`: gentle random drift with perlin-like smoothness
- [ ] `Orbit`: circular path around center point
- [ ] Add unit tests for each motion behavior
- [ ] Code compiles with no errors

## Implementation Notes

### Technical Approach

```rust
// crates/crt-renderer/src/effects/motion.rs
use kurbo::{Rect, Vec2};

#[derive(Clone, Debug)]
pub enum MotionBehavior {
    None,
    Bounce { velocity: Vec2 },
    Scroll { direction: Vec2 },
    Float { seed: u32, amplitude: f64 },
    Orbit { center: Vec2, radius: f64, speed: f64, angle: f64 },
}

impl MotionBehavior {
    pub fn update(&mut self, position: &mut Vec2, bounds: Rect, dt: f32) {
        match self {
            Self::None => {}
            Self::Bounce { velocity } => {
                position.x += velocity.x * dt as f64;
                position.y += velocity.y * dt as f64;
                // Reflect on bounds collision
                if position.x <= bounds.x0 || position.x >= bounds.x1 {
                    velocity.x = -velocity.x;
                }
                if position.y <= bounds.y0 || position.y >= bounds.y1 {
                    velocity.y = -velocity.y;
                }
            }
            Self::Scroll { direction } => {
                position.x += direction.x * dt as f64;
                position.y += direction.y * dt as f64;
                // Wrap around
                if position.x > bounds.x1 { position.x = bounds.x0; }
                if position.x < bounds.x0 { position.x = bounds.x1; }
                // ... same for y
            }
            // ... Float and Orbit implementations
        }
    }
}
```

### Dependencies
- CRT-T-0071 (effects module must exist)

### Files to Create
- `crates/crt-renderer/src/effects/motion.rs`

## Status Updates

*To be added during implementation*